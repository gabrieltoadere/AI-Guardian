<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Food Ingredients Scanner</title>
    <link rel="stylesheet" href="/AI-Guardian/css/common.css">
    <link rel="stylesheet" href="/AI-Guardian/css/scanning.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
</head>
<body>
    <div class="main">
        <h1>Barcode Scanner</h1>
    <button id="scanButton" onclick="startScanning()">Scan Barcode</button>
    <button id="manualInputButton" onclick="showManualInput()">Manual Input</button>

    <button onclick="window.location.href='UserPreference.html'">
        Set Allergen Preferences
    </button>
    


    <div id="camera"></div>
    <div id="camera" class="hidden"></div>
    <div id="manualInput" class="hidden">
        <input type="text" id="barcode" placeholder="Enter barcode">
        <button onclick="fetchProductInfo()">Get Ingredients</button>
    </div>


    <div id="result">
        <h2>Product Information</h2>
        <p><strong>Product Name:</strong> <span id="productName">-</span></p>
        <p><strong>Ingredients:</strong> <span id="ingredients">-</span></p>
        <p><strong>Potential Allergens:</strong> 
            <span id="allergen-warning" style="font-weight: bold;"></span>
         </p>
          
	<p><strong>Nutrient Levels:</strong> <span id="nutrientLevels">-</span></p>
        <img id="productImage" src="" alt="Product Image" class="hidden">
    </div>

    

    <!-- button to upload -->
    <p>If barcode doesn't work, you can upload a picture of the ingredient list.</p>
    <input type="file" id="imageInput" accept="image/*">
    <div id="result2" class="main">
       <h4>Extracted Text：</h4>
       <pre id="extractedText"></pre>
       <p id="warning"></p>
    </div>

    <div class="main" id="confirmSection">
    	<button id="safeFoodButton" onclick="markFood1()">Mark this as safe food</button>
    	<button id="unsafeFoodButton" onclick="markFood2()">Mark this unsafe food</button>
	<p id="notice"></p>	
	<div id="questions" class="hidden">
		<p>How many of this product did you purchase?</p>
		<input type="number" placeholder="type number">
		<p>Food Name:</p>
		<input type="text" id="foodNameInput">
		<button id="confirmButton" onclick="saveFoodHistory()">save</button>
		<p id="test"></p>
	</div>
    </div>
</div>
    

    

    
    <script src="https://cdn.jsdelivr.net/npm/@ericblade/quagga2/dist/quagga.min.js"></script>
    <script>
        let lastDetectedCode = null;
        let lastDetectionTime = 0;
        let isCameraInitialized = false;
	let foodName = null;

        function startScanning() {
            document.getElementById('camera').classList.remove('hidden');
            document.getElementById('manualInput').classList.add('hidden');

            if (!isCameraInitialized) {
                initializeScanner();
                isCameraInitialized = true;
            }
        }

        function showManualInput() {
            document.getElementById('camera').classList.add('hidden');
            document.getElementById('manualInput').classList.remove('hidden');
        }

        function initializeScanner() {
            const quaggaConf = {
    inputStream: {
        target: "#camera",  // Ensure Quagga attaches correctly
        type: "LiveStream",
        constraints: {
            width: 640,  // Explicitly set the width
            height: 480, // Set a height to keep it constrained
            facingMode: "environment",
            aspectRatio: 1.5
        }
    },
                decoder: {
                    readers: [
                        'code_128_reader',
                        'ean_reader',
                        'ean_8_reader',
                        'upc_reader',
                        'upc_e_reader',
                        'code_39_reader',
                        'code_39_vin_reader',
                        'codabar_reader',
                        'i2of5_reader',
                        '2of5_reader',
                        'code_93_reader'
                    ]
                },
                locator: {
                    patchSize: "medium",
                    halfSample: true
                },
                locate: true,
                numOfWorkers: 4
            };

            Quagga.init(quaggaConf, function(err) {
                if (err) {
                    console.error("Initialization failed: ", err);
                    return;
                }
                console.log("Initialization successful");
                Quagga.start();
            });

            Quagga.onDetected(function(result) {
                const currentCode = result.codeResult.code;
                const currentTime = Date.now();

                if (currentCode === lastDetectedCode && (currentTime - lastDetectionTime) < 5000) {
                    return;
                }

                console.log("Detected barcode: ", currentCode);
                document.getElementById('barcode').value = currentCode;
                fetchProductInfo();

                lastDetectedCode = currentCode;
                lastDetectionTime = currentTime;
            });
        }

        async function fetchProductInfo() {
            const barcode = document.getElementById('barcode').value;
            if (!barcode) {
                alert('Please enter a barcode.');
                return;
            }

            const url = `https://world.openfoodfacts.org/api/v0/product/${barcode}.json`;
            try {
                const response = await fetch(url);
                const data = await response.json();

                if (data.status === 1) {
                    const product = data.product;

                    const productName = product.product_name ||
					product.generic_name_en || 
					product.product_name_en ||
					product.product_name_it ||
                                        product.generic_name || 
                                        product.abbreviated_product_name || 
                                        product.brands || 
                                        'Unknown Product';

					foodName = productName;	

                    const ingredientsText = product.ingredients_text_en || product.ingredients_text || '';
                    const ingredientsArray = ingredientsText.split(',').map(i => i.trim().toLowerCase());

					let potentialAllergens = product.allergens || 'No data';
                        if (typeof potentialAllergens === 'string') {
                            potentialAllergens = potentialAllergens
                                .split(',')
                                .map(a => a.trim().replace(/^en:/, ''))  // remove "en:" prefix
                                .join(', ');
                        }
                        // document.getElementById('potentialAllergens').textContent = potentialAllergens;

                    document.getElementById('productName').textContent = productName;
                    document.getElementById('ingredients').textContent = ingredientsText;
                    

                    let openFoodAllergens = [];

                    if (typeof product.allergens === 'string') {
                        openFoodAllergens = product.allergens
                            .split(',')
                            .map(a => a.trim().replace(/^[a-z]{2}:/, '').toLowerCase())
                            .filter(a => a);
                    }

                    displayAllergenWarning(openFoodAllergens);




					const nutrientLevels = product.nutrient_levels || {};
					const nutrientText = Object.entries(nutrientLevels).map(([key, value]) => `${key}: ${value}`).join(", "); 		
                    
                    const userAllergens = JSON.parse(localStorage.getItem('userAllergens')) || [];

                let categoryTag = null;
                if (product.categories_tags && product.categories_tags.length > 0) {
                    categoryTag = product.categories_tags.find(tag => tag.startsWith('en:'));
                }

                if (categoryTag) {
                    console.log("✔️ Using category:", categoryTag);
                    console.log("✔️ User allergen preferences:", userAllergens);


                    fetch(`https://world.openfoodfacts.org/category/${categoryTag.replace('en:', '')}.json`)
                        .then(res => res.json())
                        .then(categoryData => {
                            const alternatives = categoryData.products.filter(p => {
                                if (!p || !p.product_name || !p.image_front_small_url) return false;
                                
                                const pAllergens = (p.allergens || '')
                                    .split(',')
                                    .map(a => a.trim().replace(/^[a-z]{2}:/, '').toLowerCase());

                                return !pAllergens.some(a => userAllergens.includes(a));
                            }).slice(0, 5); // limit to 5 safe options

                            if (alternatives.length === 0) {
                                console.log("No allergen-safe alternatives found.");
                            }

                            displayAlternativeProducts(alternatives);
                            console.log("✔️ Found total products in category:", categoryData.products.length);
                            console.log("✔️ Filtered safe alternatives:", alternatives.length);

                        })
                        .catch(error => {
                            console.error("Error fetching alternatives:", error);
                        });
                } else {
                    console.warn("No valid category found for alternatives.");
                }


					document.getElementById('nutrientLevels').textContent = nutrientText || "No data";
			
					document.getElementById('productImage').classList.remove('hidden');
                    const imageUrl = product.image_front_small_url || product.selected_images.front.small.it || "https://cdn-icons-png.flaticon.com/512/1178/1178479.png";
					document.getElementById('productImage').src = imageUrl;            

					document.getElementById('camera').classList.add('hidden');
				} else {
                    document.getElementById('productName').textContent = 'Product not found';
                    document.getElementById('ingredients').textContent = '-';
                    document.getElementById('productImage').classList.add('hidden');
                }
            } catch (error) {
                console.error('Error fetching product info:', error);
                alert('Failed to fetch product information. Please try again.');
            }

            
        }



        function compressImage(file, callback) {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = (event) => {
                const img = new Image();
                img.src = event.target.result;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    const MAX_WIDTH = 800;
                    const MAX_HEIGHT = 800;
                    let width = img.width;
                    let height = img.height;

                    if (width > height) {
                        if (width > MAX_WIDTH) {
                            height *= MAX_WIDTH / width;
                            width = MAX_WIDTH;
                        }
                    } else {
                        if (height > MAX_HEIGHT) {
                            width *= MAX_HEIGHT / height;
                            height = MAX_HEIGHT;
                        }
                    }

                    canvas.width = width;
                    canvas.height = height;

                    ctx.drawImage(img, 0, 0, width, height);

                    canvas.toBlob(
                        (blob) => {
                            if (blob.size > 1024 * 1024) {
                                canvas.toBlob(
                                    (blob) => callback(blob),
                                    'image/webp',
                                    0.7
                                );
                            } else {
                                callback(blob);
                            }
                        },
                        'image/webp',
                        0.8
                    );
                };
            };
        }

        async function processImage() {
            const imageInput = document.getElementById('imageInput');
            const extractedTextElement = document.getElementById('extractedText');
            const warningElement = document.getElementById('warning');

            if (!imageInput.files || imageInput.files.length === 0) {
                alert('Please choose a photo');
                return;
            }

            const file = imageInput.files[0];

            compressImage(file, async (compressedBlob) => {
                const formData = new FormData();
                formData.append('file', compressedBlob, 'image.webp');
                formData.append('language', 'eng');
                formData.append('OCREngine', '2');
                formData.append('isOverlayRequired', 'false');

                //const apiKey = 'K81548401288957';
				const apiKey = 'K82645357788957';
                const apiUrl = `https://api.ocr.space/parse/image`;

                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: {
                            'apikey': apiKey,
                        },
                        body: formData,
                    });
                    const result = await response.json();

                    if (result.IsErroredOnProcessing) {
                        throw new Error(result.ErrorMessage);
                    }

                    
                    document.getElementById('result2').classList.remove('hidden');

                    
                    const extractedText = result.ParsedResults[0].ParsedText;
                    extractedTextElement.textContent = extractedText;
			
					foodName = extractedText.split("\n")[0];

                    // I assume client is allergic to milk. We can change this later
                    if (extractedText.toLowerCase().includes('milk')) {
                        warningElement.textContent = "Warning! This product contains your allergens: xxxxxx";
                        warningElement.style.display = 'block'; 
                    } else {
                        warningElement.style.display = 'none'; 
                    }
                } catch (error) {
                    console.error('OCR went wrong:', error);
                    alert('OCR went wrong, please try again.');
                }
            });
        }

        document.getElementById('imageInput').addEventListener('change', processImage);


	function markFood1() {
		document.getElementById('questions').classList.remove('hidden');
		document.getElementById('foodNameInput').value = foodName;
	}


	function markFood2() {
		document.getElementById('notice').innerHTML = "This unsafe food has been stored"
	}

	function saveFoodHistory(){
		document.getElementById('test').innerHTML = foodName;
	}

   </script>
   
   
   <div class="navbar">
    <ul>
        <li><a href="main.html"><i class="fas fa-home"></i> Home</a></li>
        <li><a href="scanning.html"><i class="fas fa-barcode"></i> Scan</a></li>
        <li><a href="history.html"><i class="fas fa-history"></i> History</a></li>
        <li><a href="profile.html"><i class="fas fa-user"></i> Profile</a></li>
    </ul>
</div>

    <!-- Chatbot Icon -->
<div class="chatbot-icon" id="chatbotIcon">
    <i class="fa-solid fa-robot"></i>
</div>



<script> 
    // ✅ Display the result
    function displayAllergenWarning(allergens) {
    const warningBox = document.getElementById("allergen-warning");
    const userAllergens = JSON.parse(localStorage.getItem('userAllergens')) || [];

    const filteredAllergens = allergens.filter(allergen =>
        userAllergens.includes(allergen.toLowerCase())
    );

    if (filteredAllergens.length > 0) {
        warningBox.innerHTML = `⚠️ <span style="color:red;">Warning: Contains ${filteredAllergens.join(", ")}</span>`;
    } else {
        warningBox.innerHTML = `✅ <span style="color:green;">No allergens detected based on your preferences.</span>`;
    }
}
    </script>




<script>
function displayAlternativeProducts(products) {
    const container = document.getElementById("alternativeList");
    container.innerHTML = '';

    if (products.length === 0) {
        container.innerHTML = '<p>No allergen-safe alternatives found in this category.</p>';
        return;
    }

    products.forEach(p => {
        const item = document.createElement('div');
        item.style.border = "1px solid #ccc";
        item.style.padding = "10px";
        item.style.borderRadius = "8px";
        item.style.width = "150px";
        item.style.textAlign = "center";

        item.innerHTML = `
            <img src="${p.image_front_small_url || 'https://cdn-icons-png.flaticon.com/512/1178/1178479.png'}" 
                 alt="product" style="width: 100px; height: 100px; object-fit: contain;">
            <p>${p.product_name || 'Unnamed Product'}</p>
        `;
        container.appendChild(item);
    });
}
</script>





</body>
</html>

<!-- 


// ** Fetch Alternative Products **
async function fetchAlternativeProducts(allergens) {
    const barcode = document.getElementById('barcode').value.trim();
    if (!barcode) return;

    const productUrl = `https://world.openfoodfacts.org/api/v0/product/${barcode}.json`;

    try {
        const productResponse = await fetch(productUrl);
        const productData = await productResponse.json();

        if (productData.status !== 1) {
            console.error("Original product not found.");
            return;
        }

        // Extract categories from the scanned product
        const possibleCategories = productData.product.categories_tags || [];
        console.log("Possible categories:", possibleCategories);

        // Default to categories like chocolates, but also consider others
        const relevantCategories = ["chocolates", "cocoa-products", "candies", "sweets", "snacks"];
        const matchedCategory = possibleCategories.find(cat => relevantCategories.includes(cat)) || "chocolates";

        console.log("Using category:", matchedCategory);

        // Build the exclusion query to avoid allergens
        let exclusionQuery = allergens.map(allergen => `-ingredients_text:${encodeURIComponent(allergen)}`).join("&");
        
            // Fetch alternative products from the same category but excluding allergens
            const searchUrl = `https://world.openfoodfacts.org/cgi/search.pl?action=process&tagtype_0=categories&tag_contains_0=contains&tag_0=${matchedCategory}&sort_by=popularity&json=1&fields=product_name,ingredients_text,image_url&${exclusionQuery}`;
        
            const searchResponse = await fetch(searchUrl);
            const searchData = await searchResponse.json();
        
            const alternativeList = document.getElementById('alternativeProducts');
            alternativeList.innerHTML = ''; // Clear previous suggestions
        
            const validAlternatives = searchData.products.filter(product => {
                if (!product.ingredients_text) return false;
        
                // Exclude products that contain any of the user's allergens
                return !allergens.some(allergen => product.ingredients_text.toLowerCase().includes(allergen.toLowerCase()));
            });
        
            if (validAlternatives.length > 0) {
                validAlternatives.slice(0, 3).forEach(product => {
                    const li = document.createElement('li');
                    
                    // Use the English name if available, else use the original name
                    const productName = product.product_name_en || product.product_name || 'Unknown Product';
                    
                    li.innerHTML = `<strong>${productName}</strong>`;
        
                    if (product.image_url) {
                        li.innerHTML += `<br><img src="${product.image_url}" width="100" alt="Alternative product image">`;
                    }
        
                    alternativeList.appendChild(li);
                });
            } else {
                alternativeList.innerHTML = '<li>No safe alternatives found for your allergens.</li>';
            }
        } catch (error) {
            console.error("Error fetching alternative products:", error);
        }
    } -->